import { execSync } from 'child_process';
import * as path from 'path';

/**
 * Git validation check result
 */
interface GitValidationCheck {
  name: string;
  passed: boolean;
  message: string;
  details?: string[];
}

/**
 * Git validation report
 */
interface GitValidationReport {
  timestamp: string;
  overallStatus: 'pass' | 'fail';
  checks: GitValidationCheck[];
  summary: {
    total: number;
    passed: number;
    failed: number;
  };
}

/**
 * Commit information
 */
interface CommitInfo {
  hash: string;
  message: string;
  author: string;
  date: string;
}

const PROJECT_DIR = path.join(__dirname, '..');

/**
 * Main git validation function
 */
function validateGitHistory(): GitValidationReport {
  const checks: GitValidationCheck[] = [];
  
  console.log('ðŸ” Validating git history...\n');
  
  // Check 1: Git repository exists
  checks.push(validateGitRepo());
  
  // Check 2: Commit count >= 15
  checks.push(validateCommitCount());
  
  // Check 3: AI attribution in commits
  checks.push(validateAIAttribution());
  
  // Check 4: Atomic commits
  checks.push(validateAtomicCommits());
  
  // Check 5: MCP mentions in commits
  checks.push(validateMCPCommits());
  
  return generateReport(checks);
}

/**
 * Check if git repository exists
 */
function validateGitRepo(): GitValidationCheck {
  try {
    execSync('git rev-parse --git-dir', { 
      cwd: PROJECT_DIR,
      stdio: 'pipe'
    });
    
    return {
      name: 'Git Repository',
      passed: true,
      message: 'Git repository found'
    };
  } catch (error) {
    return {
      name: 'Git Repository',
      passed: false,
      message: 'Not a git repository',
      details: ['Initialize git repository with: git init']
    };
  }
}

/**
 * Validate commit count
 */
function validateCommitCount(): GitValidationCheck {
  try {
    const output = execSync('git rev-list --count HEAD', {
      cwd: PROJECT_DIR,
      encoding: 'utf-8',
      stdio: 'pipe'
    });
    
    const count = parseInt(output.trim(), 10);
    
    return {
      name: 'Commit Count',
      passed: count >= 15,
      message: `Found ${count} commits (minimum: 15)`,
      details: count < 15 ? [`Need ${15 - count} more commits`] : undefined
    };
  } catch (error) {
    return {
      name: 'Commit Count',
      passed: false,
      message: 'Error counting commits',
      details: [String(error)]
    };
  }
}

/**
 * Validate AI attribution in commits
 */
function validateAIAttribution(): GitValidationCheck {
  try {
    const commits = getCommits();
    
    if (commits.length === 0) {
      return {
        name: 'AI Attribution',
        passed: false,
        message: 'No commits found'
      };
    }
    
    // Check for AI-related keywords in commit messages
    const aiKeywords = [
      /ai.generated/i,
      /generated.by/i,
      /kiro/i,
      /ai.assisted/i,
      /copilot/i,
      /\[ai\]/i,
      /\[kiro\]/i
    ];
    
    const aiCommits = commits.filter(commit => 
      aiKeywords.some(pattern => pattern.test(commit.message))
    );
    
    const percentage = (aiCommits.length / commits.length) * 100;
    
    return {
      name: 'AI Attribution',
      passed: aiCommits.length >= 5,
      message: `${aiCommits.length} commits with AI attribution (${percentage.toFixed(1)}%)`,
      details: aiCommits.length < 5 ? [
        `Need ${5 - aiCommits.length} more commits with AI attribution`,
        'Add keywords like: [AI], [Kiro], AI-generated, Generated by Kiro'
      ] : undefined
    };
  } catch (error) {
    return {
      name: 'AI Attribution',
      passed: false,
      message: 'Error checking AI attribution',
      details: [String(error)]
    };
  }
}

/**
 * Validate atomic commits
 */
function validateAtomicCommits(): GitValidationCheck {
  try {
    const commits = getCommits();
    
    if (commits.length === 0) {
      return {
        name: 'Atomic Commits',
        passed: false,
        message: 'No commits found'
      };
    }
    
    // Check for commits with very long messages (might indicate non-atomic)
    const longCommits = commits.filter(commit => 
      commit.message.length > 200
    );
    
    // Check for commits with generic messages
    const genericMessages = [
      /^update$/i,
      /^fix$/i,
      /^changes$/i,
      /^wip$/i,
      /^temp$/i
    ];
    
    const genericCommits = commits.filter(commit =>
      genericMessages.some(pattern => pattern.test(commit.message))
    );
    
    const issues: string[] = [];
    if (longCommits.length > commits.length * 0.3) {
      issues.push(`${longCommits.length} commits have very long messages`);
    }
    if (genericCommits.length > commits.length * 0.2) {
      issues.push(`${genericCommits.length} commits have generic messages`);
    }
    
    return {
      name: 'Atomic Commits',
      passed: issues.length === 0,
      message: issues.length === 0
        ? 'Commits appear to be atomic'
        : 'Some commits may not be atomic',
      details: issues.length > 0 ? issues : undefined
    };
  } catch (error) {
    return {
      name: 'Atomic Commits',
      passed: false,
      message: 'Error checking commit atomicity',
      details: [String(error)]
    };
  }
}

/**
 * Validate MCP mentions in commits
 */
function validateMCPCommits(): GitValidationCheck {
  try {
    const commits = getCommits();
    
    if (commits.length === 0) {
      return {
        name: 'MCP Commits',
        passed: false,
        message: 'No commits found'
      };
    }
    
    // Check for MCP-related keywords
    const mcpKeywords = [
      /mcp/i,
      /playwright.*mcp/i,
      /context7.*mcp/i,
      /model.*context.*protocol/i
    ];
    
    const mcpCommits = commits.filter(commit =>
      mcpKeywords.some(pattern => pattern.test(commit.message))
    );
    
    return {
      name: 'MCP Commits',
      passed: mcpCommits.length >= 2,
      message: `${mcpCommits.length} commits mention MCP (minimum: 2)`,
      details: mcpCommits.length < 2 ? [
        `Need ${2 - mcpCommits.length} more commits mentioning MCP`,
        'Include MCP references in commit messages when integrating MCP features'
      ] : undefined
    };
  } catch (error) {
    return {
      name: 'MCP Commits',
      passed: false,
      message: 'Error checking MCP commits',
      details: [String(error)]
    };
  }
}

/**
 * Get list of commits
 */
function getCommits(): CommitInfo[] {
  try {
    const output = execSync(
      'git log --pretty=format:"%H|%s|%an|%ad" --date=short',
      {
        cwd: PROJECT_DIR,
        encoding: 'utf-8',
        stdio: 'pipe'
      }
    );
    
    if (!output.trim()) {
      return [];
    }
    
    return output.trim().split('\n').map(line => {
      const [hash, message, author, date] = line.split('|');
      return { hash, message, author, date };
    });
  } catch (error) {
    return [];
  }
}

/**
 * Generate validation report
 */
function generateReport(checks: GitValidationCheck[]): GitValidationReport {
  const passed = checks.filter(c => c.passed).length;
  const failed = checks.filter(c => !c.passed).length;
  
  return {
    timestamp: new Date().toISOString(),
    overallStatus: failed === 0 ? 'pass' : 'fail',
    checks,
    summary: {
      total: checks.length,
      passed,
      failed
    }
  };
}

/**
 * Print report to console
 */
function printReport(report: GitValidationReport): void {
  console.log('\n' + '='.repeat(60));
  console.log('ðŸ” GIT HISTORY VALIDATION REPORT');
  console.log('='.repeat(60));
  console.log(`Timestamp: ${report.timestamp}`);
  console.log(`Status: ${report.overallStatus === 'pass' ? 'âœ… PASS' : 'âŒ FAIL'}`);
  console.log(`\nSummary: ${report.summary.passed}/${report.summary.total} checks passed\n`);
  
  for (const check of report.checks) {
    const icon = check.passed ? 'âœ…' : 'âŒ';
    console.log(`${icon} ${check.name}: ${check.message}`);
    
    if (check.details && check.details.length > 0) {
      for (const detail of check.details) {
        console.log(`   - ${detail}`);
      }
    }
  }
  
  console.log('\n' + '='.repeat(60));
  
  if (report.overallStatus === 'fail') {
    console.log('\nâš ï¸  Some git history checks failed. Please address the issues above.');
  } else {
    console.log('\nðŸŽ‰ All git history checks passed!');
  }
  
  // Show recent commits
  try {
    console.log('\nðŸ“ Recent Commits:');
    const commits = getCommits().slice(0, 10);
    commits.forEach(commit => {
      console.log(`   ${commit.hash.substring(0, 7)} - ${commit.message}`);
    });
  } catch (error) {
    // Ignore errors when showing commits
  }
}

// Run validation
const report = validateGitHistory();
printReport(report);

// Exit with appropriate code
process.exit(report.overallStatus === 'pass' ? 0 : 1);
